/*
 * Copyright (c) 2025, Open Pixel Systems
 *
 * SPDX-License-Identifier: MIT
 */

#pragma once

#include <stddef.h>
#include <stdint.h>

// If not defined, set the maximum length of the information field to 255
#ifndef HDLC_INFO_MAX_LEN
#define HDLC_INFO_MAX_LEN 255
#endif

// Check if the maximum length of the information field is less than or equal to 255
#if HDLC_INFO_MAX_LEN > 0xFF
#error "HDLC_INFO_MAX_LEN must be less than or equal to 255"
#endif

// Type definitions used in the HDLC frame
typedef uint8_t hdlc_address_t;
typedef uint8_t hdlc_info_t[HDLC_INFO_MAX_LEN];
typedef uint8_t hdlc_info_len_t;

/**
 * @brief HDLC control field
 */
typedef union {
	uint8_t value; // Control field value
	struct {
		uint8_t res1: 1; // Reserved bit
		uint8_t ns: 3;   // Send sequence number
		uint8_t pf: 1;   // Poll/final bit
		uint8_t nr: 3;   // Receive sequence number
	} __attribute__((packed)) i_fields;
	struct {
		uint8_t res1: 1; // Reserved bit
		uint8_t res2: 1; // Reserved bit
		uint8_t s: 2;    // Supervisory code (S)
		uint8_t pf: 1;   // Poll/final bit
		uint8_t nr: 3;   // Receive sequence number
	} __attribute__((packed)) s_fields;
	struct {
		uint8_t res1: 1; // Reserved bit
		uint8_t res2: 1; // Reserved bit
		uint8_t m1: 2;   // Un-numbered bits (M1)
		uint8_t pf: 1;   // Poll/final bit
		uint8_t m2: 3;   // Un-numbered bits (M2)
	} __attribute__((packed)) u_fields;
} __attribute__((packed)) hdlc_control_t;

/**
 * @brief HDLC supervisory frame codes for S-frames
 */
typedef enum {
	HDLC_CONTROL_S_FRAME_CODE_RR = 0x00,  // Receiver ready to accept more I-frames
	HDLC_CONTROL_S_FRAME_CODE_REJ = 0x01, // Go back N retransmission request for an I-frame
	HDLC_CONTROL_S_FRAME_CODE_RNR = 0x02, // Receive not ready to accept more I-frames
	HDLC_CONTROL_S_FRAME_CODE_SREJ = 0x03 // Selective retransmission request for an I-frame
} hdlc_control_s_frame_code_t;

/**
 * @brief HDLC un-numbered frame codes for U-frames
 */
typedef enum {
	HDLC_CONTROL_U_FRAME_CODE_SNRM,  // Set normal response mode
	HDLC_CONTROL_U_FRAME_CODE_SABM,  // Set asynchronous balanced mode
	HDLC_CONTROL_U_FRAME_CODE_SABME, // Set asynchronous balanced mode, extended
	HDLC_CONTROL_U_FRAME_CODE_DISC,  // Disconnect
	HDLC_CONTROL_U_FRAME_CODE_UA,    // Un-numbered acknowledgement
	HDLC_CONTROL_U_FRAME_CODE_RSET,  // Reset send and receive sequence numbers
	HDLC_CONTROL_U_FRAME_CODE_FRMR,  // Frame reject
} hdlc_control_u_frame_code_t;

/**
 * @brief HDLC frame states (used during decoding)
 */
typedef enum {
	HDLC_STATE_START_FLAG, // Decode the start flag
	HDLC_STATE_ADDRESS,    // Decode the address field
	HDLC_STATE_CONTROL,    // Decode the control field
	HDLC_STATE_INFO,       // Decode the information field
	HDLC_STATE_FCS,        // Decode the frame check sequence
	HDLC_STATE_STOP_FLAG,  // Decode the stop flag
} hdlc_state_t;

/**
 * @brief HDLC frame, holds the fields of an HDLC frame (excluding start flag, FCS and stop flag)
 */
typedef struct {
	hdlc_address_t address; // Address field
	hdlc_control_t control; // Control field (should be generated by one of the init functions)
	hdlc_info_t info;       // Information field
	hdlc_info_len_t info_len; // Information field length
} __attribute__((packed)) hdlc_frame_t;

/**
 * @brief Initialize an HDLC frame
 * @param frame Pointer to HDLC frame
 * @return 0 on success, -1 on error
 */
int hdlc_frame_init(hdlc_frame_t *frame);

/**
 * @brief Initialize an I-frame control field
 * @param control Pointer to HDLC control field
 * @param ns Send sequence number
 * @param pf Poll/final bit
 * @param nr Receive sequence number
 * @return 0 on success, -1 on error
 */
int hdlc_i_frame_control_init(hdlc_control_t *control, uint8_t ns, uint8_t pf, uint8_t nr);

/**
 * @brief Initialize an S-frame control field
 * @param control Pointer to HDLC control field
 * @param s Supervisory frame code (S)
 * @param pf Poll/final bit
 * @param nr Receive sequence number
 * @return 0 on success, -1 on error
 */
int hdlc_s_frame_control_init(hdlc_control_t *control, hdlc_control_s_frame_code_t s, uint8_t pf,
			      uint8_t nr);

/**
 * @brief Initialize a U-frame control field
 * @param control Pointer to HDLC control field
 * @param m Un-numbered frame code (M)
 * @param pf Poll/final bit
 * @return 0 on success, -1 on error
 */
int hdlc_u_frame_control_init(hdlc_control_t *control, hdlc_control_u_frame_code_t m, uint8_t pf);

/**
 * @brief Encode an HDLC frame
 * @param frame Pointer to HDLC frame
 * @param data Pointer to data buffer
 * @param len Length of data buffer
 * @return Number of bytes in the data buffer on success, -1 on error
 */
int hdlc_encode(const hdlc_frame_t *frame, uint8_t *data, int len);

/**
 * @brief Decode an HDLC frame
 * @param frame Pointer to HDLC frame
 * @param data Pointer to data buffer
 * @param len Length of data buffer
 * @return 0 on success, -1 on error
 */
int hdlc_decode(hdlc_frame_t *frame, uint8_t *data, int len);